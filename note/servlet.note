线程安全问题
	当多个客户的并发访问同一个Servlet时，服务器会为每一个客户端访问请求创建一个线程，如果service方法调用统一资源的话， 可能引发线程安全问题。

ServletConfig
	servlet配置文件中， <init-param>初始化参数
ServletContext
	代表当前web应用 context域对象
	this.getServletConfig().getServletContext();	// 方式1
	this.getServletContext();		// 方式2
	多个servlet之间通话

	<Context-param>标签之间配ServletContext对象
	实现Servlet转发
		RequestDispatcher rd = this.getServletContext().getRequestDispatcher("*.jsp");
		rd.forward(request, response);
	管理资源文件 (xml properties)
		得到文件路径
			this.getServletContext().getResourceAsStream("/");

	注意：普通java对象中，需要通过类装载器读文件, 但是文件不能太大，容易内存溢出
	1. InputStream in = UserDao.class.getClassLoder().getResourceAsStream("*.properties");
	2. String path = UserDao.class.getClassLoder().getResource("*.properties").getPath();

HttpServletResponse
	response.setHeader("Content-type", "text/html;charset=UTF-8");	// 控制浏览器编码
	response.getOutputStream()
	
	<meta> 可以模拟http响应头
	<meta http-equiv='content-type' content='text/html;charset=utf-8'

	文件下载功能{
		String path = this.getServletContext().getRealPath("");// 资源路径

		response.setHeader("content-dispsition", "attachment;filename="+filename);//设置http响应头 为下载

		response.setHeader("content-dispsition", "attachment;filename="+URLEncoder.encode(filename, "utf-8"));//如果文件名为中文，需要转码
	}

	控制浏览器定时刷新
		response.setHeader("refresh", "3");

	response控制浏览器缓存
		response.setDateHeader("Expries", System.currentTimeMillis() + 1000 * 3600);// 一个小时内不要缓存
	
	response请求重定向
		response.setStatus(302);
		response.setHeader("location",	"");
		或
		response.setRedirect("");
		发送了两次请求 尽量少用 因为要加重服务器负担
		必须要请求重定向的地方举例：登录、购物
	
	response 的 getOutputStream 和 getWriter方法在一个response中只能用一次
