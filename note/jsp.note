JSP -- Java Server Pages
	jsp 输出当前系统时间
		{
			<%
				Date date = new Date();
				out.write(date.toLocalString());
			%>
		}
	jsp 调用和运行原理
		HttpJspBase的子类, HttpJspBase 继承自HttpServlet
		可以直接使用request response等
	
	JSP模板元素
		jsp页面中的html
	脚本表达式
		<%=name %>
	脚本片段 <%%> 可以不完整，整体必须完整
	注释 
		<%-- --%>
	
	JSP指令
		语法： <%@ 指令 属性名＝"值" %>
		page指令
			<%@ page
				[language="java"]
				[extends="packgae.class"]
				[import=""]
				[session="true/false"]
				[isThreadSafe="true"]		// 是否线程安全
				[errorPage="/*.jsp"]	// 出错的页面
				[isErrorPage="true"]
			%>
		include指令
			<%@include file="/*.jsp" %>
			包含的页面不需要head body等标签
			静态包含，转成一个servlet
			request.getRequestDispatcher("").inclde(request, response);	// 动态包含
			静态包含性能好，尽量使用静态包含
		taglib指令

	jsp 运行原理
		第一次访问时需要转成servlet 所以速度比较慢
	
	九大隐式对象
		request response session application config page out exception pageContext

		out对象 JspWrite类
			<%
				out.write("hahaha");
				response.getWriter().write("wowowowo");
			%>
			结果： wowowowohahaha
		pageContext对象
			jsp中最重要的对象，可以获取其他隐式对象
			自定义标签的时候，需要用到
			pageContext.findAttribute("data"); // 按page request session applation中查找值
	
	JSP标签
		<jsp:forward page="*.*"></jsp:forward>
		<jsp:include page="*.*"></jsp:include> <%-- 动态包含 --%>
		<jsp:param name="" value=""></jsp:param>
	
	jsp 映射
		<servlet>
			<servlet-name></servlet-name>
			<jsp-file></jsp-file>
		</servlet>
	JSP中的错误
		1. 如果jsp语法错误导致没法生成servlet，错误讲显示jsp出错的行列位置
		2. jsp页面中jsp语法没问题，但是翻译成的servlet源文件中出现了java语法问题，导致jsp翻译成的servlet文件不能通过编译，提示jsp页面的行列
		3. 翻译成servlet后在运行时候出现异常，提示错误信息在servlet源文件的位置

javaBean
	1. java类必须有一个无参构造函数
	2. 属性必须私有化
	3. 私有化的属性必须通过public类型的方法暴露给其他程序，并且方法的命名也必须遵守一定的规范

自定义标签
	1. 编写实现Tag接口的java类 javax.servlet.jsp.tagext
	2. 编写标签哭描述符(tld)文件，把标签处理器类描述成一个标签
		setPageContext(PageContext pc)

	test:
		自定义标签，输出客户ip

		public class ViewIpTag extends TagSupport {
			
			public int doStartTag() throws JspException {
				HttpServletRequest req = (HttpServletRequest)this.pageContext.getRequest();
				JspWriter out = this.pageContext.getOut();
				String ip = request.getRemoteAddr();
				out.print(ip);
			}
		}

	
	流程：
		1.遇到自定义标签，首先实例化标签对应的处理器类
		2. 调用setPageContext方法，把pageContext对象传递给标签处理器类
		3. 如果有父标签，将父标签传给setParent方法，没有则传递null
		3. 开始执行标签，执行doStartTag方法
		4. 如果有标签体，开始执行标签体
		5. 遇到结束标签，执行doEnd方法
		6. 标签执行完后，一般情况会掉用release方法，释放资源
	
	自定义标签功能扩展
		1. 控制jsp页面某部分页面是否执行
		2. 控制整个jsp页面是否执行
		3. 控制jsp内容重复执行
		4. 修改页面内容

	test :
		控制标签体之行5次
		int i = 5;
		public int doStartTag() throws JspException {
			return Tag.EVAL_BODY_INCLUDE;
		}

		public int doAfterBody() throws JspException {
			x--;
			if(x > 0) {
				return IterationTag.EVAL_BODY_AGAIN;
			} else {
				return IterationTag.SKIP_BODY;
			}
		}
	
	控制标签中的内容
		doStartTag中 return BodyTag.EVAL_BODY_BUFFERED;
		doEndTag中， this.getbodyContent();
		this.pageContext.getOut().write();

	简单标签库开发 
		继承SimpleTagSupport类
		setJspBody -> doTag
		1. 遇到简单标签
		2. 实例化标签处理器类
		3. setJspCont
		4. 传递父标签setParent发放，如果没有传null
		5. setJspBody吧封装了标签体的JspFragment传给标签处理器类
		5. 执行标签，doTag

		控制标签体执行
			public class SimpleTagDemo extends SimpleTagSupport {
				public void doTag() throws JspException, IOException {
					JspFragment jf = this.getJspBody();
					jf.invoke(this.getJspContext().getOut());	// 同jf.invoke(null);
				}
			}

		不执行：
			doTag()中不写代码即可
		修改标签题内容
			public void doTag() throws JspException, IOException {
				JspFragment jf = this.getJspBody();
				StringWriter sw = new StringWriter();
				jf.invoke(sw);

				String content = sw.toString();
				content = content.toUpperCase();

				this.getJspContext().getOut().write(content);
			}

		带属性的标签
			1. 在标签处理器类中，编写每个属性对应的setter方法
			2. 在tld文件中描述属性

		开发防盗链标签
			<ls:referer site="http://localhost" page="/index.jsp" />

			public class RefererTag extends SimpleTagSupport {
				private String site;
				private String page;

				public void setSite(String site) {
					this.site = site;
				}

				public void setPage(String page) {
					this.page = page;
				}

				public void doTag() throws JspException, IoException {
					PageContext pageContext - (PageContext)this.getJspContext();
					HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();
					HttpServletResponse resp = (HttpServeltResponse) pageContext.getResponse();

					// 1.得到访问者referer
					String referer = request.getHeader("referer");
					if(referer == null || !referer.startsWith(site)) {
						//resp.sendRedirect(request.getContextPath() + "/" + page);
						if(page.startWith(request.getContextPath())) {
							resp.sendRedirect(page);
						} else if(page.setartWith("/")) {
							resp.sendRedirect(request.getContextPath() + page);
						} else {
							resp.sendRedirect(request.getContextPath() + "/" + page);
						}
						throw new SkipPageException();
					} else {
						
					}
				}
			}
		choose when标签
			ChooseTag parent = this.getParent();
